package kotlin.reflect.jvm.internal.impl.util;

import com.google.android.exoplayer2.text.ttml.TtmlNode;
import java.util.Set;
import kotlin.collections.SetsKt__SetsKt;
import kotlin.collections.SetsKt___SetsKt;
import kotlin.jvm.internal.Intrinsics;
import kotlin.reflect.jvm.internal.impl.name.Name;
import kotlin.text.Regex;
/* compiled from: OperatorNameConventions.kt */
/* loaded from: classes4.dex */
public final class OperatorNameConventions {
    public static final Name AND;
    public static final Set<Name> ASSIGNMENT_OPERATIONS;
    public static final Set<Name> BINARY_OPERATION_NAMES;
    public static final Set<Name> BITWISE_OPERATION_NAMES;
    public static final Name COMPARE_TO;
    public static final Regex COMPONENT_REGEX;
    public static final Name CONTAINS;
    public static final Name DEC;
    public static final Name DIV;
    public static final Name DIV_ASSIGN;
    public static final Name EQUALS;
    public static final Name GET;
    public static final Name GET_VALUE;
    public static final Name HAS_NEXT;
    public static final Name INC;
    public static final Name INV;
    public static final Name INVOKE;
    public static final Name ITERATOR;
    public static final Name MINUS;
    public static final Name MINUS_ASSIGN;
    public static final Name MOD;
    public static final Name MOD_ASSIGN;
    public static final Name NEXT;
    public static final Name NOT;

    /* renamed from: OR */
    public static final Name f1392OR;
    public static final Name PLUS;
    public static final Name PLUS_ASSIGN;
    public static final Name PROVIDE_DELEGATE;
    public static final Name RANGE_TO;
    public static final Name RANGE_UNTIL;
    public static final Name REM;
    public static final Name REM_ASSIGN;
    public static final Name SET;
    public static final Name SET_VALUE;
    public static final Name SHL;
    public static final Name SHR;
    public static final Set<Name> SIMPLE_UNARY_OPERATION_NAMES;
    public static final Name TIMES;
    public static final Name TIMES_ASSIGN;
    public static final Name UNARY_MINUS;
    public static final Name UNARY_PLUS;
    public static final Name USHR;
    public static final Name XOR;

    private OperatorNameConventions() {
    }

    static {
        Set<Name> of;
        Set<Name> of2;
        Set<Name> of3;
        Set plus;
        Set of4;
        Set<Name> of5;
        new OperatorNameConventions();
        Name identifier = Name.identifier("getValue");
        Intrinsics.checkNotNullExpressionValue(identifier, "identifier(\"getValue\")");
        GET_VALUE = identifier;
        Name identifier2 = Name.identifier("setValue");
        Intrinsics.checkNotNullExpressionValue(identifier2, "identifier(\"setValue\")");
        SET_VALUE = identifier2;
        Name identifier3 = Name.identifier("provideDelegate");
        Intrinsics.checkNotNullExpressionValue(identifier3, "identifier(\"provideDelegate\")");
        PROVIDE_DELEGATE = identifier3;
        Name identifier4 = Name.identifier("equals");
        Intrinsics.checkNotNullExpressionValue(identifier4, "identifier(\"equals\")");
        EQUALS = identifier4;
        Intrinsics.checkNotNullExpressionValue(Name.identifier("hashCode"), "identifier(\"hashCode\")");
        Name identifier5 = Name.identifier("compareTo");
        Intrinsics.checkNotNullExpressionValue(identifier5, "identifier(\"compareTo\")");
        COMPARE_TO = identifier5;
        Name identifier6 = Name.identifier("contains");
        Intrinsics.checkNotNullExpressionValue(identifier6, "identifier(\"contains\")");
        CONTAINS = identifier6;
        Name identifier7 = Name.identifier("invoke");
        Intrinsics.checkNotNullExpressionValue(identifier7, "identifier(\"invoke\")");
        INVOKE = identifier7;
        Name identifier8 = Name.identifier("iterator");
        Intrinsics.checkNotNullExpressionValue(identifier8, "identifier(\"iterator\")");
        ITERATOR = identifier8;
        Name identifier9 = Name.identifier("get");
        Intrinsics.checkNotNullExpressionValue(identifier9, "identifier(\"get\")");
        GET = identifier9;
        Name identifier10 = Name.identifier("set");
        Intrinsics.checkNotNullExpressionValue(identifier10, "identifier(\"set\")");
        SET = identifier10;
        Name identifier11 = Name.identifier("next");
        Intrinsics.checkNotNullExpressionValue(identifier11, "identifier(\"next\")");
        NEXT = identifier11;
        Name identifier12 = Name.identifier("hasNext");
        Intrinsics.checkNotNullExpressionValue(identifier12, "identifier(\"hasNext\")");
        HAS_NEXT = identifier12;
        Intrinsics.checkNotNullExpressionValue(Name.identifier("toString"), "identifier(\"toString\")");
        COMPONENT_REGEX = new Regex("component\\d+");
        Name identifier13 = Name.identifier("and");
        Intrinsics.checkNotNullExpressionValue(identifier13, "identifier(\"and\")");
        AND = identifier13;
        Name identifier14 = Name.identifier("or");
        Intrinsics.checkNotNullExpressionValue(identifier14, "identifier(\"or\")");
        f1392OR = identifier14;
        Name identifier15 = Name.identifier("xor");
        Intrinsics.checkNotNullExpressionValue(identifier15, "identifier(\"xor\")");
        XOR = identifier15;
        Name identifier16 = Name.identifier("inv");
        Intrinsics.checkNotNullExpressionValue(identifier16, "identifier(\"inv\")");
        INV = identifier16;
        Name identifier17 = Name.identifier("shl");
        Intrinsics.checkNotNullExpressionValue(identifier17, "identifier(\"shl\")");
        SHL = identifier17;
        Name identifier18 = Name.identifier("shr");
        Intrinsics.checkNotNullExpressionValue(identifier18, "identifier(\"shr\")");
        SHR = identifier18;
        Name identifier19 = Name.identifier("ushr");
        Intrinsics.checkNotNullExpressionValue(identifier19, "identifier(\"ushr\")");
        USHR = identifier19;
        Name identifier20 = Name.identifier("inc");
        Intrinsics.checkNotNullExpressionValue(identifier20, "identifier(\"inc\")");
        INC = identifier20;
        Name identifier21 = Name.identifier("dec");
        Intrinsics.checkNotNullExpressionValue(identifier21, "identifier(\"dec\")");
        DEC = identifier21;
        Name identifier22 = Name.identifier("plus");
        Intrinsics.checkNotNullExpressionValue(identifier22, "identifier(\"plus\")");
        PLUS = identifier22;
        Name identifier23 = Name.identifier("minus");
        Intrinsics.checkNotNullExpressionValue(identifier23, "identifier(\"minus\")");
        MINUS = identifier23;
        Name identifier24 = Name.identifier("not");
        Intrinsics.checkNotNullExpressionValue(identifier24, "identifier(\"not\")");
        NOT = identifier24;
        Name identifier25 = Name.identifier("unaryMinus");
        Intrinsics.checkNotNullExpressionValue(identifier25, "identifier(\"unaryMinus\")");
        UNARY_MINUS = identifier25;
        Name identifier26 = Name.identifier("unaryPlus");
        Intrinsics.checkNotNullExpressionValue(identifier26, "identifier(\"unaryPlus\")");
        UNARY_PLUS = identifier26;
        Name identifier27 = Name.identifier("times");
        Intrinsics.checkNotNullExpressionValue(identifier27, "identifier(\"times\")");
        TIMES = identifier27;
        Name identifier28 = Name.identifier(TtmlNode.TAG_DIV);
        Intrinsics.checkNotNullExpressionValue(identifier28, "identifier(\"div\")");
        DIV = identifier28;
        Name identifier29 = Name.identifier("mod");
        Intrinsics.checkNotNullExpressionValue(identifier29, "identifier(\"mod\")");
        MOD = identifier29;
        Name identifier30 = Name.identifier("rem");
        Intrinsics.checkNotNullExpressionValue(identifier30, "identifier(\"rem\")");
        REM = identifier30;
        Name identifier31 = Name.identifier("rangeTo");
        Intrinsics.checkNotNullExpressionValue(identifier31, "identifier(\"rangeTo\")");
        RANGE_TO = identifier31;
        Name identifier32 = Name.identifier("rangeUntil");
        Intrinsics.checkNotNullExpressionValue(identifier32, "identifier(\"rangeUntil\")");
        RANGE_UNTIL = identifier32;
        Name identifier33 = Name.identifier("timesAssign");
        Intrinsics.checkNotNullExpressionValue(identifier33, "identifier(\"timesAssign\")");
        TIMES_ASSIGN = identifier33;
        Name identifier34 = Name.identifier("divAssign");
        Intrinsics.checkNotNullExpressionValue(identifier34, "identifier(\"divAssign\")");
        DIV_ASSIGN = identifier34;
        Name identifier35 = Name.identifier("modAssign");
        Intrinsics.checkNotNullExpressionValue(identifier35, "identifier(\"modAssign\")");
        MOD_ASSIGN = identifier35;
        Name identifier36 = Name.identifier("remAssign");
        Intrinsics.checkNotNullExpressionValue(identifier36, "identifier(\"remAssign\")");
        REM_ASSIGN = identifier36;
        Name identifier37 = Name.identifier("plusAssign");
        Intrinsics.checkNotNullExpressionValue(identifier37, "identifier(\"plusAssign\")");
        PLUS_ASSIGN = identifier37;
        Name identifier38 = Name.identifier("minusAssign");
        Intrinsics.checkNotNullExpressionValue(identifier38, "identifier(\"minusAssign\")");
        MINUS_ASSIGN = identifier38;
        SetsKt__SetsKt.setOf((Object[]) new Name[]{identifier20, identifier21, identifier26, identifier25, identifier24, identifier16});
        of = SetsKt__SetsKt.setOf((Object[]) new Name[]{identifier26, identifier25, identifier24, identifier16});
        SIMPLE_UNARY_OPERATION_NAMES = of;
        of2 = SetsKt__SetsKt.setOf((Object[]) new Name[]{identifier27, identifier22, identifier23, identifier28, identifier29, identifier30, identifier31, identifier32});
        BINARY_OPERATION_NAMES = of2;
        of3 = SetsKt__SetsKt.setOf((Object[]) new Name[]{identifier13, identifier14, identifier15, identifier16, identifier17, identifier18, identifier19});
        BITWISE_OPERATION_NAMES = of3;
        plus = SetsKt___SetsKt.plus((Set) of2, (Iterable) of3);
        of4 = SetsKt__SetsKt.setOf((Object[]) new Name[]{identifier4, identifier6, identifier5});
        SetsKt___SetsKt.plus((Set) plus, (Iterable) of4);
        of5 = SetsKt__SetsKt.setOf((Object[]) new Name[]{identifier33, identifier34, identifier35, identifier36, identifier37, identifier38});
        ASSIGNMENT_OPERATIONS = of5;
        SetsKt__SetsKt.setOf((Object[]) new Name[]{identifier, identifier2, identifier3});
    }
}
